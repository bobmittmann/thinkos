#!/usr/bin/env python

#
# Copyright(C) 2012 Robinson Mittmann. All Rights Reserved.
# 
# This file is part of the YARD-ICE.
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public
# License as published by the Free Software Foundation; either
# version 3.0 of the License, or (at your option) any later version.
# 
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
# 
# You can receive a copy of the GNU Lesser General Public License from 
# http://www.gnu.org/

#
#    File: mkver.py
# Comment: 
#  Author: Robinson Mittmann <bobmittmann@gmail.com>
# 

import sys
import os
import codecs
import datetime
import time 
import random
import yaml
import traceback

__version__ = '0.2'

# --- constants
PY3 = sys.version_info >= (3, 0)

def replacelst(s, lst, val):
  for c in lst:
      s = s.replace(c, val)
  return s

class ShellCmd(object):
  def __init__(self, name, alias, param, brief, desc, \
               prefix = None, suffix = None):
    if prefix is not None: 
      self.prefix = prefix
    else:
      self.prefix = ''
    if suffix is not None: 
      self.suffix = suffix
    else:
      self.suffix = ''

    self.name = name
    self.alias = alias
    self.param = param
    if brief is not None: 
      self.brief = brief.strip()
    else:
      self.brief = ''
    if desc is not None: 
      self.desc = desc.strip()
    else:
      self.desc = ''
    self.sym = self.prefix + 'cmd_' + name + self.suffix
    self.val = 0

  def __repr__(self):
    return "{}('{}')".format(self.__class__.__name__, self.name)

  def __lt__(self, other):
    return self.name < other.name

  def __le__(self, other):
    return self.name <= other.name

  def __gt__(self, other):
    return self.name > other.name

  def __ge__(self, other):
    return self.name >= other.name

  def __eq__(self, other):
    return self.name == other.name

  def __ne__(self, other):
    return self.name != other.name

  def csym(self):
    return self.sym

  def cdef(self):
    return self.sym.upper()


class CmdTab(list):
  def __init__(self, prefix = None, suffix = None):
    super().__init__()
    if prefix is not None: 
      self.prefix = prefix + '_'
    else:
      self.prefix = ''
    if suffix is not None: 
      self.suffix = '_' + suffix
    else:
      self.suffix = ''

  def load_yaml(self, fname):
    fin = open(fname, 'rb')
    data = fin.read();
    fin.close()
    
    for entry in yaml.load(data):
      name = entry['cmd']
      try:
        alias = entry['alias']
      except:
        alias = None
      try:
        param = entry['param']
      except:
        param = None
      try:
        brief = entry['usage']
      except:
        brief = None
      try:
        desc = entry['help']
      except:
        desc = None
      cmd = ShellCmd(name, alias, param, brief, desc, self.prefix, self.suffix)

      if cmd in self:
        raise Exception("Duplicate entry: '{:s}'", name)
      self.append(cmd)

    self.sort()

    for i in range(0, len(self)):
      self[i].val = i + 1
      self[i].idx = i + 1

  def print(self):
    for cmd in self:
      print('{:12s} {:3d}'.format(cmd.name, cmd.idx))

  def mk_sym(self, name):
    return self.prefix + name + self.suffix;

  def mk_cdef(self, name, val = None):
    cdef = '#define ' + self.mk_sym(name).upper()
    if val is not None:
      cdef +=  ' ' + str(val)
    return cdef

  def call_ret(self):
    return 'int'

  def call_parm(self):
    return 'int argc, char * argv[]'

  def call_type(self):
    return self.prefix + 'cmd_callback_t'

  def call_typedef(self):
    return self.call_ret() + '(* ' + self.prefix + 'cmd_callback_t)(' + self.call_parm() + ')'

  def call_dec(self, sym):
    return self.call_ret() + ' ' + sym + '(' + self.call_parm() + ')'




def mk_cmdtab_h(f, fname, cmd_tab):

  prefix = cmd_tab.prefix
  suffix = cmd_tab.suffix

  if fname:
    sym = replacelst(fname, [' ', '-', '.'], '_') 
    hdef = '__' + sym.upper() + '__'
  else:
    hdef = None

  f.write('/*---------------------------------------------------------------------------\n')
  f.write('  This file was automatically generated by mkcmd.py. DO NOT edit!\n')
  f.write('  ---------------------------------------------------------------------------*/\n')
  f.write('\n')
  if hdef:
    f.write('#ifndef ' + hdef + '\n')
    f.write('#define ' + hdef + '\n')
    f.write('\n')
  f.write('#include <stdint.h>\n')
  f.write('\n')
  for cmd in cmd_tab:
    f.write('#define {:12s} {:4d}\n'.format(cmd.cdef(), cmd.val))
  f.write('\n')
  f.write(cmd_tab.mk_cdef('CMD_FIRST', cmd_tab[0].val) + '\n')
  f.write(cmd_tab.mk_cdef('CMD_LAST', cmd_tab[-1].val) + '\n')
  f.write('\n')
  f.write('typedef ' + cmd_tab.call_typedef() + ';\n')
  f.write('\n')
  f.write('extern const char * const ' + prefix + 'cmd_sym_tab[];\n')
  f.write('extern const char * const ' + prefix + 'cmd_brief_tab[];\n')
  f.write('extern const char * const ' + prefix + 'cmd_desc_tab[];\n')
  f.write('extern const char ' + prefix + 'cmd_alias_tab[][4];\n')
  f.write('\n')
  f.write('extern ' + cmd_tab.call_type() + ' const ' + prefix + 'cmd_call_tab[];\n')
  f.write('\n')
  f.write('#ifdef __cplusplus\n')
  f.write('extern \"C\" {\n')
  f.write('#endif\n')
  f.write('\n')
  f.write('int ' + prefix + 'cmd_lookup(const char * str);\n')
  f.write('\n')
  f.write('/*---------------------------------------------------------------------------\n')
  f.write('  Callbacks!\n')
  f.write('  ---------------------------------------------------------------------------*/\n')
  f.write('\n')
  for cmd in cmd_tab:
    f.write(cmd_tab.call_dec(cmd.csym()) + ';\n')
  f.write('\n')

  f.write('#ifdef __cplusplus\n')
  f.write('}\n')
  f.write('#endif\n')

  f.write('\n')
  if hdef:
    f.write('#endif /* ' + hdef + ' */\n')
  f.write('\n')

def dump_tab(f, prefix, tab, n, name):
  f.write('{:s} uint8_t {:s}[] = {{'.format(prefix, name))
  for i in range(0, n):
    if ((i % 8) == 0):
      if (i == 0):
        f.write("\n\t")
      else:
        f.write(",\n\t")
    else:
      f.write(", ")
    f.write('{:3d}'.format(tab[i]))
  f.write('\n};\n\n')

def mk_si_tab(htab):
  n = len(htab)
  s_len = 0
  s_max = 0
  for i in range(0, n):
    j = htab[i]
    if j != 0:
      s_len += 1
      if j > s_max:
        s_max = j + 1

  si_tab = []
  for i in range(0, n):
    j = htab[i]
    if j != 0:
      si_tab.append((i, j))
  
  si_tab.sort()
  s_tab = []
  i_tab = []
  for x in si_tab:
    s_tab.append(x[0])
    i_tab.append(x[1])

  return (s_tab, i_tab)

def dump_stab(f, prefix, tab, name):
  f.write('{:s} uint8_t {:s}[][2] = {{'.format(prefix, name))
  tab.sort()
  n = len(tab)
  for i in range(0, n):
    if ((i % 8) == 0):
      if (i == 0):
        f.write("\n\t")
      else:
        f.write(",\n\t")
    else:
      f.write(", ")
    f.write('{{{:3d}, {:3d} }}'.format(tab[i][0], tab[i][1]))
  f.write('\n};\n\n')


def p_hash(tab, s):
  h = 0
  for c in s:
    i = h ^ ord(c)
    h = tab[i]
  return h

def hash_lookup(h_tab, h):
  h = 0
  for c in s:
    i = h ^ ord(c)
    h = tab[i]
  return h

def mk_p_tab(tab, len, seed):
  random.seed(seed)

  for i in range(0, len):
    tab[i] = i

  for i in range(len - 1, 0, -1):
    j = random.randint(0, i)
    tmp = tab[i]
    tab[i] = tab[j]
    tab[j] = tmp

  return tab

def mktabs(f, cmd_tab):
  h_len = 128
  p_len = 128
  h_tab = [0] * h_len
  p_tab = [0] * p_len
  seed = 10000

  k = 0
  for k in range(0, 100000):
    collision = False
    seed += 1
    mk_p_tab(p_tab, p_len, seed)

# mark the buckets as empty
    for i in range(0, h_len):
      h_tab[i] = 0

    for cmd in cmd_tab:
      j = p_hash(p_tab, cmd.name);
      if (h_tab[j] != 0):
# collision 
        collision = True
        break
      h_tab[j] = cmd.val
      
      if cmd.alias is not None:
        j = p_hash(p_tab, cmd.alias);
        if (h_tab[j] != 0):
# collision 
          collision = True
          break
        h_tab[j] = cmd.val

    if (collision == False):
      f.write('/*\n')
      f.write('   Table generated with Fisher and Yates permutation\n')
      f.write('   algorithm\n')
      f.write('*/\n')
      f.write('\n')
      dump_tab(f, "static const", p_tab, p_len, "p_tab");
      (s_tab, i_tab) = mk_si_tab(h_tab);
      dump_tab(f, "static const", s_tab, len(s_tab), "s_tab");
      dump_tab(f, "static const", i_tab, len(i_tab), "i_tab");
      return h_len
  return 0
 
def mk_cmdtab_c(f, hdr_fname, cmd_tab):

  prefix = cmd_tab.prefix
  suffix = cmd_tab.suffix

  f.write('/*---------------------------------------------------------------------------\n')
  f.write('  This file was automatically generated by mkcmd.py. DO NOT edit!\n')
  f.write('  ---------------------------------------------------------------------------*/\n')
  f.write('\n')
  f.write('#include <stdlib.h>\n')
  f.write('#include \"{:s}\"\n'.format(hdr_fname))
  f.write('\n')

  f.write('\n')
  f.write('const char * const ' + prefix + 'cmd_sym_tab[] = {\n')
  for cmd in cmd_tab:
    f.write('\t[{:s}] = \"{:s}\",\n'.format(cmd.cdef(), cmd.name))
  f.write('};\n')
  f.write('\n')
  f.write('const char * const ' + prefix + 'cmd_brief_tab[] = {\n')
  for cmd in cmd_tab:
    f.write('\t[{:s}] = \"{:s}\",\n'.format(cmd.cdef(), cmd.brief))
  f.write('};\n')
  f.write('\n')
  f.write('const char * const ' + prefix + 'cmd_desc_tab[] = {\n')
  for cmd in cmd_tab:
    f.write('\t[{:s}] = \"{:s}\",\n'.format(cmd.cdef(), cmd.desc))
  f.write('};\n')
  f.write('\n')
  f.write('const char ' + prefix + 'cmd_alias_tab[][4] = {\n')
  for cmd in cmd_tab:
    if cmd.alias is not None:
      f.write('\t[{:s}] = \"{:s}\",\n'.format(cmd.cdef(), cmd.alias))
    else:
      f.write('\t[{:s}] = \"\",\n'.format(cmd.cdef()))
  f.write('};\n')
  f.write('\n')

  f.write('const char * const ' + prefix + 'cmd_param_tab[] = {\n')
  for cmd in cmd_tab:
    f.write('\t[{:s}] = '.format(cmd.cdef()))
    if cmd.param is not None:
      lead = '\"'
      for p in cmd.param:
        f.write('{:s}{:s}'.format(lead, p))
        lead = ' | '
      f.write('\"')
    else:
      f.write('NULL')
    f.write(',\n')
  f.write('};\n')
  f.write('\n')

  f.write('const ' + prefix + 'cmd_callback_t ' + prefix + 'cmd_call_tab[] = {\n')
  for cmd in cmd_tab:
    f.write('\t[{:s}] = {:s},\n'.format(cmd.cdef(), cmd.csym()))
  f.write('};\n')
  f.write('\n')

  mktabs(f, cmd_tab)

  f.write('static int h_lookup(int x)\n')
  f.write('{\n')
  f.write('\tint i = 0;\n')
  f.write('\tint j = sizeof(s_tab) - 1;\n')
  f.write('\n')
  f.write('\twhile (i <= j) {\n')
  f.write('\t\tint k = i + ((j - i) / 2);\n')
  f.write('\t\tint y = s_tab[k];\n')
  f.write('\t\tif (y == x) {\n')
  f.write('\t\t\treturn k;\n')
  f.write('\t\t} else if (y < x) {\n')
  f.write('\t\t\ti = k + 1;\n')
  f.write('\t\t} else {\n')
  f.write('\t\t\tj = k - 1;\n')
  f.write('\t\t}\n')
  f.write('\t}\n')
  f.write('\n')
  f.write('\treturn -1;\n')
  f.write('}\n')
  f.write('\n')
  f.write('int ' + prefix + 'cmd_lookup(const char * str)\n')
  f.write('{\n')
  f.write('\tint h = 0;\n')
  f.write('\tint c;\n')
  f.write('\tint i;\n')
  f.write('\tint y;\n')
  f.write('\n')
  f.write('\tfor (i = 0; (c = str[i]) != \'\\0\'; ++i) {\n')
  f.write('\t\th = p_tab[c ^ h];\n')
  f.write('\t}\n')
  f.write('\n')
  f.write('\tif ((y = h_lookup(h)) < 0) {\n')
  f.write('\t\treturn y;\n')
  f.write('\t}\n')
  f.write('\n')
  f.write('\treturn i_tab[y];\n')
  f.write('}\n')
  f.write('\n')


def error(msg):
  sys.stdout.flush()
  f = sys.stderr
  f.write("\n")
  f.write("{0}: error: {1}\n".format(progname, msg))
  f.write("\n")
  f.write(traceback.format_exc())
  f.flush()

def main(argv):
  global progname 

  progname = argv[0]

  from optparse import OptionParser
  parser = OptionParser(usage='''
  %prog yamlfile
  %prog -n [name]''', version=__version__)
  parser.add_option("-o", "--output", dest="outfname", 
    help="write result to FILE", metavar="FILE")
  parser.add_option("-p", "--prefix", dest="prefix", 
    help="use PREFIX before name on symbol declarations", metavar="PREFIX")
  parser.add_option("-s", "--suffix", dest="suffix", 
    help="use SUFFIX after name on symbol declarations", metavar="SUFFIX")
  parser.add_option("-H", "--header", dest="header", 
    help="write header file", metavar="HEADER")

  options, args = parser.parse_args()

  if not args:
    parser.print_help()
    return 1

  infile = args[0]

#  if options.name:
#    name = options.name
#  else:
#    name = replacelst(os.path.basename(infile), [' ', '-', '.'], '_') 

  if options.outfname:
    out_fname = options.outfname
  else:
    out_fname = None

  if options.header:
    hdr_fname = options.header
  else:
    if out_fname:
      dirname, fname = os.path.split(out_fname)
      basename, extension = os.path.splitext(fname)
      hdr_fname = basename + '.h'
    else:
      hdr_fname = None

  cmd_tab = CmdTab(options.prefix, options.suffix)

  try:
    cmd_tab.load_yaml(infile)
  except Exception as err:
    error(err)
    return 2

  cmd_tab.print();

  try:
    if out_fname is not None:
      fout_c = codecs.open(out_fname, 'w+', encoding='utf8')
    else:
      fout_c = sys.stdout

    mk_cmdtab_c(fout_c, hdr_fname, cmd_tab)

    if out_fname is not None:
      fout_c.close() 
  except Exception as err:
    error(err)
    return 3

  try:
    if hdr_fname:
      fout_h = codecs.open(hdr_fname, 'w+', encoding='utf8')
    else:
      fout_h = sys.stdout

    mk_cmdtab_h(fout_h, hdr_fname, cmd_tab)

    if hdr_fname:
      fout_h.close()
  except Exception as err:
    error(err)
    return 4

  return 0

if __name__ == '__main__':
  ret = main(sys.argv)
  sys.exit(ret)

