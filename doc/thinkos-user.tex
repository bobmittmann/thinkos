\input{thinkos-common.tex}

% Define Title Author Date and Revision
\makeatletter         
\title{ThinkOS - User Guide}
\author{Bob Mittmann}
\date{January 2017}
\def\email{bobmittmann@gmail.com} % revision number variable
\def\therevision{0.1} % revision number variable
\let\thetitle\@title % title variable
\makeatother

\begin{document}

\maketitle
\thispagestyle{empty}
\newpage
\pagenumbering{Roman}
\tableofcontents
\newpage
\listoffigures
\newpage
\listoftables
\newpage

% Start of the revision history table
\begin{versionhistory}
  \vhEntry{0.1}{21.01.17}{BM}{created}
\end{versionhistory}

\newpage
\pagenumbering{arabic}

\section{Introduction}

\lettrine{T}{his} user guide provides an overview of the \ThinkOS real-time operating system. The target audience for this guide are embedded software developers knowledgeable in C language. Notice that no mention of C++ is made in this text.\\

\ThinkOS was designed specifically for the \textbf{Cortex-M} family of microprocessors from \textbf{ARM}. These are all 32bits CPUs with mostly 16bits instruction set, which produces very compact code, hence suitable for deep embedded systems with stringent memory and other peripheral resources constraints.

At this moment \ThinkOS supports \textbf{M3}, \textbf{M4} and \textbf{M7} cores.

The popular \textbf{M0} family lacks some features needed for some operations in the kernel. Porting to these platforms is feasible but needs someone with time to do that. Any volunteer?

ThinkOS is a Real Time Operating System designed for the ARM Cortex-M core. It takes advantage of some unique features of this processor to enable for very low task switch latency.


\subsection{Why Another OS?}

The real answer for this question perhaps is simply: ``Just because I can''. But as most people won't be satisfied with this shallow reply here are some justifications:

\subsection{Where do I can get ThinkOS from?}

\begin{flushleft}
Repository: [\href{https://github.com/bobmittmann/thinkos}{https://github.com/bobmittmann/thinkos}]\\
Git HTTPS: [\href{https://github.com/bobmittmann/thinkos.git}{https://github.com/bobmittmann/thinkos.git}]
\end{flushleft}

\subsection{Performance}

The main bottleneck for performance is usually the scheduler. The ThinkOS running in a 120MHz Cortex-M3 (STM32F270) have a measured latency time of 0.5 microseconds.

There are some tests and calculations that need to be done to determine the latency of other elements of the system...

\section {Quick Start}

\section{ThinkOS Basics}

\lstset {language=C99}

In this tutorial the most basic \ThinkOS functions are described with some code examples. This is a summary of what it will be covered in this section:

\begin{itemize}
\item How to create and run threads.
\item Create, lock and unlock mutexes.
\item Create, signal and wait on semaphores.
\item Wait for time intervals (sleep).
\item Create a new thread
\end{itemize}

\subsection{Creating a Thread}

The easiest way to create and run a thread is to call \lstinline{thinkos_thread_create()}. Here is an example: 

\begin{lstlisting}[caption={Simple Thread Create Example},label={lst:example1},language=C99,frame=single]
static int my_task(void * arg)
{
    for (;;) {
        /* do something ... */
         thinkos_sleep(50);
    }
    return 0;
}

static uint32_t my_stack[256]; /* 1KB of stack is enough for most porposes */

void my_module_init(void)
{
    thinkos_thread_create(my_task, NULL, my_stack, sizeof(my_stack));
}
\end{lstlisting}

In this example we define a function to be the entry point of the thread, in this case \lstinline{my_task()}. We also define an array of 32bit words, amounting to 1KB, to be used as stack for the thread (\lstinline{my_stack}). We then call \lstinline{thinkos_thread_create()} which will allocate and run the thread. The return of this function is the thread id or a negative error code in case something goes wrong.

\subsubsection{Using semaphores}

ThinkOS semaphores allow processes and threads to synchronize their actions.

A semaphore is an integer whose value is never allowed to fall below zero. Two operations can be performed on semaphores: increment the semaphore value by one (\lstinline{thinkos_sem_post()}); and decrement the semaphore value by one (\lstinline{thinkos_sem_wait()}). If the value of a semaphore is currently zero, then a \lstinline{thinkos_sem_wait()} operation will block until the value becomes greater than zero. A semaphore should be allocated with \lstinline{thinkos_sem_alloc()} which will return a descriptor to be used in subsequent calls to  \lstinline{thinkos_sem_post()}, and \lstinline{thinkos_sem_wait()}.

In the example below, two treads are created: a producer and a consumer. The producer signals the semaphore periodically twice a second, whereas the consumer waits for the signal and prints a message when receives it.

\begin{lstlisting}[caption={Using semaphores example},label={lst:example2},language=C99,frame=single]
/* Global semaphore descriptor */

int my_sem;

/* Producer thread */
static int producer_task(void * arg)
{
    for (;;) {
        /* Wait 500 milliseconds... */
        thinkos_sleep(500);
        /* Signal the semaphore. */
        thinkos_sem_post(my_sem);
    }
    return 0;
}

/* Consumer thread */
static int consumer_task(void * arg)
{
    for (;;) {
        /* Wait on the semaphore... */
        thinkos_sem_wait(my_sem);
        /* Do something... */
        printf("Signal received\n");
    }
    return 0;
}


static uint32_t consumer_stack[256];
static uint32_t producer_stack[256];

void my_test_init(void)
{
    /* Allocate a semaphore with 0 initial count. */
    my_sem = thinkos_sem_alloc(0);
    /* Create a thread to signal the semaphore */
    thinkos_thread_create(producer_task, NULL, producer_stack, sizeof(producer_stack));
    /* Create a thread to wait on the semaphore */
    thinkos_thread_create(consumer_task, NULL, consumer_stack, sizeof(consumer_stack));
}
\end{lstlisting}

\subsubsection{Using MUTEXes}

A mutex is a MUTual EXclusion device, and is useful for protecting shared data structures from concurrent modifications, and implementing critical sections and monitors.

A mutex has two possible states: unlocked (not owned by any thread), and locked (owned by one thread). A mutex can never be owned by two different threads simultaneously. A thread attempting to lock a mutex that is already locked by another thread is suspended until the owning thread unlocks the mutex first.

A call to \lstinline{thinkos_mutex_lock()} locks the given mutex. If the mutex is currently unlocked, it becomes locked and owned by the calling thread, and \lstinline{thinkos_mutex_lock()} returns immediately. If the mutex is already locked by another thread, \lstinline{thinkos_mutex_lock()} suspends the calling thread until the mutex is unlocked by calling \lstinline{thinkos_mutex_unlock()}. A mutex should be allocated with \lstinline{thinkos_mutex_alloc()} which will return a descriptor to be used in subsequent mutex calls.

In the following example the serial port is a resource that needs to be protected to ensure the packets are transmitted in full.


\begin{lstlisting}[caption={Using MutExes examples},label={lst:example3},language=C99,frame=single]
/* Link Layer private data */
static struct {
	uint8_t addr; /* this panel address */
	
	
    struct serial_dev * serial; /* serial device driver */
    int mutex; /* protect the link layer send call */
} rs485;

void netlnk_send(unsigned int daddr, void * data, unsigned int len)
{
    struct lnkhdr hdr;

    /* lock the mutex, blocking the access to the serial port... */
    thinkos_mutex_lock(rs485.mutex);
    /* prepare header */
    hdr.sync = PKT_SYNC;
    hdr.daddr = daddr;
    hdr.saddr = rs485.addr;
    hdr.datalen = len;
    /* send header */
    serial_send(rs485.serial, &hdr, sizeof(struct lnkhdr));
    /* send payload */
    serial_send(rs485.serial, data, len);
    /* unlock mutex, other thread can use the serial port now. */
    thinkos_mutex_unlock(rs485.mutex);
}

void netlnk_init(unsigned int addr)
{
    /* Open the serial port */
    rs485.serial = stm32f_uart1_serial_init(9600, SERIAL_8N1);
    /* Set the local address */
    rs485.addr = addr;
    /* Allocate a mutex */
    rs485.mutex = thinkos_mutex_alloc();
}
\end{lstlisting}

\subsubsection{Time Wait}

Use the \lstinline{thinkos_sleep()} function to wait for a period of time. The calling thread suspends its execution until at least the time specified as parameter has elapsed. The time period is specified in milliseconds.
The example that follows a LED will blink repeatedly 4 times per second:

\begin{lstlisting}[caption={Time Wait Example},label={lst:example4},language=C99,frame=single]
int blink_task(void * arg)
{
    for (;;) {
        led_on();           /* Turn LED on */
        thinkos_sleep(100); /* Wait for 100 milliseconds */
        led_off();          /* Turn LED off */
        thinkos_sleep(150); /* Wait for 150 milliseconds */
    }

    return 0;
}
\end{lstlisting}

\subsubsection{Compiling the Code}

In order to compile the code in a Windows machine you must first install these tools:
\begin{itemize}
\item GNU Toolchain for ARM Processors for Windows hosts.
\item GNU Make for Windows.
\end{itemize}

\subsubsection{Compiling Using the Command Shell}

You can use the windows Command Prompt or a MinGW/MSYS terminal to compile the code.
Open a windows shell: Start->All Programs->Accessories->Command Prompt
Change to the directory  in the ThinkOS source tree.
Type: make

\section{API}

The ThinkOS API can be separated according to the type of object the operation is performed ...

Core - initialization configuration and debug Threads - functions related to threads Mutexes Conditional Variables Semaphores Events Interrupts Time Kernel Objects

One feature that distinguish the ThinkOS from most of other Operating Systems is the way the control structures for the several type of objects are held by kernel. The usual approach for holding this information is to allocate a structure specific for a certain object and pass a pointer to the kernel. The kernel then stores this in a list or array. ThinkOS in other hand holds the information on a structure of arrays, each array refers to one field of an object. This may look very obscure but the idea here is to protect the memory and speed-up the scheduler.

Threads

The ThinkOS is a preemptive time-sharing kernel. Each thread have it's own stack and a timer. This timer is used to block the thread's execution for a certain period of time as in \lstinline{thinkos_sleep()}.

Scheduler

ThinkOS scheduler was designed to reduce the context switch time to a minimum. The most important piece on the Kernel is the Scheduler....

Time Sharing

All threads with priority higher than 0 go into a round-robin time sharing scheduling policy, when this feature is enabled. Their execution time will be inversely proportional to their priority.

Interrupt Model

There are two types of interrupt handlers with ThinkOS:

Implicit ISR - Thread interrupt handlers that executes as normal threads. This is a simple call to \lstinline{thinkos_irq_wait(IRQ)} inside a regular task or function. The thread will block until this interrupt is raised. This mechanism provides a convenient and powerful tool to design drivers. Devices that benefit most of this type of ISR are simplex I/O channels like I2C or SPI, hardware accelerators like cryptographic ...

Native ISR - Normal interrupt handlers that shares a common stack. These handlers are subject to to some constraints regarding API calls. It is recommended to use this type of interrupt handler when low latency is a must. But bare in mind that if the handler is too complex the actual latency due to loading registers and housekeeping may be equivalent to a context switch in which case it will be equivalent of a threaded handler in terms of performance. Another case will be a high priority interrupt you want to make sure it will won't be preempted...

Configuration

The file \lstinline{include/thinkos_sys.h} contains the definition of the structures used by the OS. In this file there is a series of macros used to set default values for the configuration options.

It is not recommended to change the values directly in \lstinline{thinkos_sys.h}, create a \lstinline{config.h} file instead, and define the macro \lstinline{CONFIG_H} at the compiler's: \lstinline{-DCONFIG_H}.

Note: if you are using the \ThinkOS as part of the YARD-ICE there is a \lstinline{config.h} file located at the source root.


\section {API}

\section {Tools}
% = SECTION ===================================================================
\section{Tools}

% == SUB-SECTION =========================================
\subsection{MSYS-2}

MSYS2 is software distribution and a building platform for Windows. It provides a Unix-like environment, a command-line interface and a software repository making it easier to install, use, build and port software on Windows.\\

The official website is:

\href{http://www.msys2.org/}{MSYS2 Website}\\

Useful information can be found at the project's wiki pages at: 

\href{https://github.com/msys2/msys2/wiki/MSYS2-introduction}{MSYS2 Introduction}\\

% == SUB-SECTION =========================================
\subsection{GNU Toolchain for ARM Processors}

ThinnkOS on Windows Host - this document is a guide on how to set-up the tools and environment to develop ThinkOS applications using a Windows computer as host............

The GNU toolchain is a broad collection of programming tools developed by the GNU Project. These tools form a toolchain (a suite of tools used in a serial manner) used for developing software applications and operating systems.

If you are a windows user, you can download and install the GNU Toolchain for ARM Processors from the site: https://launchpad.net/gcc-arm-embedded. At the time of writing this document the latest version known to work with YARD-ICE was 4.9-2015-q3, which can be downloaded directly from:

\begin{flushleft}
GNU Arm Embedded Toolchain at Launchpad:
[\href{https://launchpad.net/gcc-arm-embedded}{https://launchpad.net/gcc-arm-embedded}]\\
\end{flushleft}

\begin{flushleft}
[\href{https://developer.arm.com/open-source/gnu-toolchain/gnu-rm}{GNU Arm Embedded Toolchain}]\\

Downloads: [\href{https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads}{https://developer.arm.com/open-source/gnu-toolchain/gnu-rm/downloads}\\
\end{flushleft}

Run the downloaded file \textit{gcc-arm-none-eabi-6-2017-q2-update-win32-sha2.exe}, or newer, to start the installation.
In the next steps use the default values suggested by the wizard installer.
In the last screen, after the files were copied, select the "Add path to environment variable" option.

Alternatively a compressed (.zip) file can be downloaded (\textit{gcc-arm-none-eabi-6-2017-q2-update-win32.zip}) and extracted in a directory of choice...

\subsubsection{GNU Make for Windows}

\subsubsection{GNU Core Utils for Windows}

% == SUB-SECTION =========================================
\subsection{Python}

% == SUB-SECTION =========================================
\subsection{Eclipse}

% == SUB-SECTION =========================================
\subsection{Tera-Term}

% == SUB-SECTION =========================================
\subsection{YARD-ICE}

The YARD-ICE project is a community based, open source platform for a standalone remote debugger.

\begin{flushleft}
Repository: [\href{https://github.com/bobmittmann/yard-ice}{https://github.com/bobmittmann/yard-ice}]\\
Git HTTPS: [\href{https://github.com/bobmittmann/yard-ice.git}{https://github.com/bobmittmann/yard-ice}]
\end{flushleft}

% == SUB-SECTION =========================================
\subsubsection{DCCLog}

\section{Apendix}

\section {References}


\begin{flushleft}
\href{https://en.wikipedia.org/wiki/Real-time_operating_system}{Real-time operating system} - Wikipedia - March, 2017
\end{flushleft}

\begin{flushleft}
\href{https://www.gnu.org/gnu/thegnuproject.en.html}{The GNU Project}\\
\end{flushleft}

\begin{flushleft}
\href{https://gcc.gnu.org/}{GCC, the GNU Compiler Collection}\\
\end{flushleft}

\begin{flushleft}
\href{https://github.com/msys2/msys2/wiki}{MSYS2}\\
\end{flushleft}

\end{document}

