/* 
 * Copyright(C) 2012 Robinson Mittmann. All Rights Reserved.
 * 
 * This file is part of the libstm32f.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3.0 of the License, or (at your option) any later version.
 * 
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You can receive a copy of the GNU Lesser General Public License from 
 * http://www.gnu.org/
 */

/** 
 * @file stm32f-tim.h
 * @brief
 * @author Robinson Mittmann <bobmittmann@gmail.com>
 */ 

#ifndef __STM32F_TIMER_H__
#define __STM32F_TIMER_H__

/*-------------------------------------------------------------------------
  TIMER
  -------------------------------------------------------------------------*/

/*-------------------------------------------------------------------------
 * TIMx control register 1 */
#define STM32F_TIM_CR1 0x00

/* [15..10] Reserved, always read as 0 */

/* Bits [9..8] - Clock division */
#define TIM_CKD (((1 << (9 - 8 + 1)) - 1) << 8)
/* This bit-field indicates the division ratio between the timer 
   clock (CK_INT) frequency and sampling clock used by the digital 
   filters (ETR, TIx),
   00: tDTS = tCK_INT
   01: tDTS = 2 × tCK_INT
   10: tDTS = 4 × tCK_INT
   11: Reserved */

/* Bit 7 - Auto-reload preload enable */
#define TIM_ARPE (1 << 7)
/* 0: TIMx_ARR register is not buffered
   1: TIMx_ARR register is buffered. */

/* Bits [6..5] - Center-aligned mode selection */
#define TIM_CMS (((1 << (6 - 5 + 1)) - 1) << 5)
#define TIM_CMS_MSK (((1 << (6 - 5 + 1)) - 1) << 5)
#define TIM_CMS_SET(VAL) (((VAL) << 5) & TIM_CMS_MSK)
#define TIM_CMS_GET(REG) (((REG) & TIM_CMS_MSK) >> 5)
#define TIM_CMS_EDGE    (0x0 << 5)
#define TIM_CMS_CENTER1 (0x1 << 5)
#define TIM_CMS_CENTER2 (0x2 << 5)
#define TIM_CMS_CENTER3 (0x3 << 5)
/* 00: Edge-aligned mode. The counter counts up or down depending on 
   the direction bit (DIR).
   01: Center-aligned mode 1. The counter counts up and down alternatively. 
   Output compare interrupt flags of channels configured in output (CCxS=00 
   in TIMx_CCMRx register) are set only when the counter is counting down.
   10: Center-aligned mode 2. The counter counts up and down alternatively. 
   Output compare interrupt flags of channels configured in output (CCxS=00 
   in TIMx_CCMRx register) are set only when the counter is counting up.
   11: Center-aligned mode 3. The counter counts up and down alternatively. 
   Output compare interrupt flags of channels configured in output (CCxS=00 
   in TIMx_CCMRx register) are set both when the counter is counting up or down.
   Note: It is not allowed to switch from edge-aligned mode to center-aligned 
   mode as long as the counter is enabled (CEN=1) */

/* Bit 4 - Direction */
#define TIM_DIR (1 << 4)
#define TIM_DIR_UP (0 << 4)
#define TIM_DIR_DOWN (1 << 4)
/* 0: Counter used as upcounter
   1: Counter used as downcounter
   Note: This bit is read only when the timer is configured in 
   Center-aligned mode or Encoder mode. */

/* Bit 3 - One-pulse mode */
#define TIM_OPM (1 << 3)
/* 0: Counter is not stopped at update event
   1: Counter stops counting at the next update event (clearing the bit CEN) */

/* Bit 2 - Update request source */
#define TIM_URS (1 << 2)
/* This bit is set and cleared by software to select the UEV event sources.
   0: Any of the following events generate an update interrupt or DMA 
   request if enabled.
   These events can be:
   – Counter overflow/underflow
   – Setting the UG bit
   – Update generation through the slave mode controller
   1: Only counter overflow/underflow generates an update interrupt or 
   DMA request if enabled. */

/* Bit 1 - Update disable */
#define TIM_UDIS (1 << 1)
/* This bit is set and cleared by software to enable/disable UEV event 
   generation.
   0: UEV enabled. The Update (UEV) event is generated by one of the 
   following events:
   – Counter overflow/underflow
   – Setting the UG bit
   – Update generation through the slave mode controller
   Buffered registers are then loaded with their preload values.
   1: UEV disabled. The Update event is not generated, shadow registers 
   keep their value (ARR, PSC, CCRx). However the counter and the prescaler 
   are reinitialized if the UG bit is set or if a hardware reset is 
   received from the slave mode controller. */

/* Bit 0 - Counter enable */
#define TIM_CEN (1 << 0)
/* 0: Counter disabled
   1: Counter enabled
   Note: External clock, gated mode and encoder mode can work only if the 
   CEN bit has been previously set by software. However trigger mode can 
   set the CEN bit automatically by hardware.
   CEN is cleared automatically in one-pulse mode, when an update 
   event occurs. */


/*-------------------------------------------------------------------------
 * TIMx control register 2 */
#define STM32F_TIM_CR2 0x04

/* [15..8] Reserved, always read as 0. */

/* Bit 7 - TI1 selection */
#define TIM_TI1S (1 << 7)
/* 0: The TIMx_CH1 pin is connected to TI1 input
   1: The TIMx_CH1, CH2 and CH3 pins are connected to the TI1 input 
   (XOR combination) See also Section 13.3.18: Interfacing with Hall 
   sensors on page 325 */

/* Bits [6..4] - Master mode selection */
#define TIM_MMS ((6 - 4) << 4)
/* These bits allow to select the information to be sent in master mode 
   to slave timers for synchronization (TRGO). The combination is as follows:
   000: Reset - the UG bit from the TIMx_EGR register is used as trigger 
   output (TRGO). If the reset is generated by the trigger input (slave mode 
   controller configured in reset mode) then the signal on TRGO is delayed 
   compared to the actual reset.
   001: Enable - the Counter enable signal, CNT_EN, is used as trigger output 
   (TRGO). It is useful to start several timers at the same time or to control 
   a window in which a slave timer is enabled. The Counter Enable signal is 
   generated by a logic OR between CEN control bit and the trigger input when 
   configured in gated mode.
   When the Counter Enable signal is controlled by the trigger input, there 
   is a delay on TRGO, except if the master/slave mode is selected (see the 
   MSM bit description in TIMx_SMCR register).
   010: Update - The update event is selected as trigger output (TRGO). For 
   instance a master timer can then be used as a prescaler for a slave timer.
   011: Compare Pulse - The trigger output send a positive pulse when the 
   CC1IF flag is to be set (even if it was already high), as soon as a 
   capture or a compare match occurred. (TRGO)
   100: Compare - OC1REF signal is used as trigger output (TRGO)
   101: Compare - OC2REF signal is used as trigger output (TRGO)
   110: Compare - OC3REF signal is used as trigger output (TRGO)
   111: Compare - OC4REF signal is used as trigger output (TRGO) */

#define TIM_MMS_RESET  (0 << 4)
#define TIM_MMS_ENABLE (1 << 4)
#define TIM_MMS_UPDATE (2 << 4)
#define TIM_MMS_COMPARE_PULSE (3 << 4)
#define TIM_MMS_OC1REF (4 << 4)
#define TIM_MMS_OC2REF (5 << 4)
#define TIM_MMS_OC3REF (6 << 4)
#define TIM_MMS_OC4REF (7 << 4)

/* Bit 3 - Capture/compare DMA selection */
#define TIM_CCDS (1 << 3)
/* 0: CCx DMA request sent when CCx event occurs
   1: CCx DMA requests sent when update event occurs */

/* [2..0] Reserved, always read as 0 */


/*-------------------------------------------------------------------------
 * TIMx slave mode control register */
#define STM32F_TIM_SMCR 0x08

/* Bit 15 - External trigger polarity */
#define TIM_ETP (1 << 15)
/* This bit selects whether ETR or ETR is used for trigger operations
   0: ETR is noninverted, active at high level or rising edge
   1: ETR is inverted, active at low level or falling edge */

/* Bit 14 - External clock enable */
#define TIM_ECE (1 << 14)
/* This bit enables External clock mode 2.
   0: External clock mode 2 disabled
   1: External clock mode 2 enabled. The counter is clocked by any 
   active edge on the ETRF signal.
   1: Setting the ECE bit has the same effect as selecting external clock 
   mode 1 with TRGI connected to ETRF (SMS=111 and TS=111).
   2: It is possible to simultaneously use external clock mode 2 with the 
   following slave modes: reset mode, gated mode and trigger mode. 
   Nevertheless, TRGI must not be connected to ETRF in this case (TS bits 
   must not be 111).
   3: If external clock mode 1 and external clock mode 2 are enabled at 
   the same time, the external clock input is ETRF. */

/* Bits [13..12] - External trigger prescaler */
#define TIM_ETPS ((13 - 12) << 12)
/* External trigger signal ETRP frequency must be at most 1/4 of CK_INT 
   frequency. A prescaler can be enabled to reduce ETRP frequency. It is 
   useful when inputting fast external clocks.
   00: Prescaler OFF
   01: ETRP frequency divided by 2
   10: ETRP frequency divided by 4
   11: ETRP frequency divided by 8 */

/* Bits [11..8] - External trigger filter */
#define TIM_ETF_MSK (((1 << (11 - 8 + 1)) - 1) << 8)
#define TIM_ETF_SET(VAL) (((VAL) << 8) & TIM_ETF_MSK)
#define TIM_ETF_GET(REG) (((REG) & TIM_ETF_MSK) >> 8)
/* This bit-field then defines the frequency used to sample ETRP signal and 
   the length of the digital filter applied to ETRP. The digital filter is 
   made of an event counter in which N events are needed to validate a 
   transition on the output:
   0000: No filter, sampling is done at fDTS
   0001: fSAMPLING=fCK_INT, N=2
   0010: fSAMPLING=fCK_INT, N=4
   0011: fSAMPLING=fCK_INT, N=8
   0100: fSAMPLING=fDTS/2, N=6
   0101: fSAMPLING=fDTS/2, N=8
   0110: fSAMPLING=fDTS/4, N=6
   0111: fSAMPLING=fDTS/4, N=8
   1000: fSAMPLING=fDTS/8, N=6
   1001: fSAMPLING=fDTS/8, N=8
   1010: fSAMPLING=fDTS/16, N=5
   1011: fSAMPLING=fDTS/16, N=6
   1100: fSAMPLING=fDTS/16, N=8
   1101: fSAMPLING=fDTS/32, N=5
   1110: fSAMPLING=fDTS/32, N=6
   1111: fSAMPLING=fDTS/32, N=8 */

/* Bit 7 - Master/Slave mode */
#define TIM_MSM (1 << 7)
/* 0: No action
   1: The effect of an event on the trigger input (TRGI) is delayed to 
   allow a perfect synchronization between the current timer and its slaves 
   (through TRGO). It is useful if we want to synchronize several timers on 
   a single external event. */

/* Bits [6..4] - Trigger selection */
#define TIM_TS ((6 - 4) << 4)
#define TIM_TS_MSK (((1 << (6 - 4 + 1)) - 1) << 4)
#define TIM_TS_SET(VAL) (((VAL) << 4) & TIM_TS_MSK)
#define TIM_TS_GET(REG) (((REG) & TIM_TS_MSK) >> 4)
/* This bit-field selects the trigger input to be used to synchronize 
   the counter.
   000: Internal Trigger 0 (ITR0).
   001: Internal Trigger 1 (ITR1).
   010: Internal Trigger 2 (ITR2).
   011: Internal Trigger 3 (ITR3).
   100: TI1 Edge Detector (TI1F_ED)
   101: Filtered Timer Input 1 (TI1FP1)
   110: Filtered Timer Input 2 (TI2FP2)
   111: External Trigger input (ETRF)
   See Table 60: TIMx internal trigger connection on page 398for more details 
   on ITRx meaning for each Timer.
   Note: These bits must be changed only when they are not used (e.g. 
   when SMS=000) to avoid wrong edge detections at the transition. */
#define TIM_TS_ITR0     (0 << 0)
#define TIM_TS_ITR1     (1 << 0)
#define TIM_TS_ITR2     (2 << 0)
#define TIM_TS_ITR3     (3 << 0)
#define TIM_TS_TI1F_ED  (4 << 0)
#define TIM_TS_TI1FP1   (5 << 0)
#define TIM_TS_TI2FP2   (6 << 0)
#define TIM_TS_ETRF     (7 << 0)

/* Bit 3 Reserved, always read as 0. */

/* Bits [2..0] - Slave mode selection */
#define TIM_SMS ((2 - 0) << 0)
#define TIM_SMS_MSK (((1 << (2 - 0 + 1)) - 1) << 0)
#define TIM_SMS_SET(VAL) (((VAL) << 0) & TIM_SMS_MSK)
#define TIM_SMS_GET(REG) (((REG) & TIM_SMS_MSK) >> 0)
/* When external signals are selected the active edge of the trigger signal 
   (TRGI) is linked to the polarity selected on the external input (see 
   Input Control register and Control Register description.
   000: Slave mode disabled - if CEN = ‘1 then the prescaler is clocked 
   directly by the internal clock.
   001: Encoder mode 1 - Counter counts up/down on TI2FP2 edge depending 
   on TI1FP1 level.
   010: Encoder mode 2 - Counter counts up/down on TI1FP1 edge depending 
   on TI2FP2 level.
   011: Encoder mode 3 - Counter counts up/down on both TI1FP1 and TI2FP2 
   edges depending on the level of the other input.
   100: Reset Mode - Rising edge of the selected trigger input (TRGI) 
   reinitializes the counter and generates an update of the registers.
   101: Gated Mode - The counter clock is enabled when the trigger input 
   (TRGI) is high. The counter stops (but is not reset) as soon as the 
   trigger becomes low. Both start and stop of the counter are controlled.
   110: Trigger Mode - The counter starts at a rising edge of the trigger 
   TRGI (but it is not reset). Only the start of the counter is controlled.
   111: External Clock Mode 1 - Rising edges of the selected trigger (TRGI) 
   clock the counter.
   Note: The gated mode must not be used if TI1F_ED is selected as the 
   trigger input (TS=100).
   Indeed, TI1F_ED outputs 1 pulse for each transition on TI1F, whereas the 
   gated mode checks the level of the trigger signal. */
#define TIM_SMS_DISABLED      (0 << 0)
#define TIM_SMS_ENCODER_MODE1 (1 << 0)
#define TIM_SMS_ENCODER_MODE2 (2 << 0)
#define TIM_SMS_ENCODER_MODE3 (3 << 0)
#define TIM_SMS_RESET_MODE    (4 << 0)
#define TIM_SMS_GATED_MODE    (5 << 0)
#define TIM_SMS_TRIGGER_MODE  (6 << 0)
#define TIM_SMS_EXTCLK1_MODE  (7 << 0)

/*-------------------------------------------------------------------------
 * TIMx DMA/Interrupt enable register */
#define STM32F_TIM_DIER 0x0C

/* Bit 15 Reserved, always read as 0. */

/* Bit 14 - Trigger DMA request enable */
#define TIM_TDE (1 << 14)
/* 0: Trigger DMA request disabled.
   1: Trigger DMA request enabled. */

/* Bit 13 Reserved, always read as 0 */

/* Bit 12 - Capture/Compare 4 DMA request enable */
#define TIM_CC4DE (1 << 12)
/* 0: CC4 DMA request disabled.
   1: CC4 DMA request enabled. */

/* Bit 11 - Capture/Compare 3 DMA request enable */
#define TIM_CC3DE (1 << 11)
/* 0: CC3 DMA request disabled.
   1: CC3 DMA request enabled. */

/* Bit 10 - Capture/Compare 2 DMA request enable */
#define TIM_CC2DE (1 << 10)
/* 0: CC2 DMA request disabled.
   1: CC2 DMA request enabled. */

/* Bit 9 - Capture/Compare 1 DMA request enable */
#define TIM_CC1DE (1 << 9)
/* 0: CC1 DMA request disabled.
   1: CC1 DMA request enabled. */

/* Bit 8 - Update DMA request enable */
#define TIM_UDE (1 << 8)
/* 0: Update DMA request disabled.
   1: Update DMA request enabled. */

/* Bit 7 Reserved, always read as 0. */

/* Bit 6 - Trigger interrupt enable */
#define TIM_TIE (1 << 6)
/* 0: Trigger interrupt disabled.
   1: Trigger interrupt enabled. */

/* Bit 5 Reserved, always read as 0. */

/* Bit 4 - Capture/Compare 4 interrupt enable */
#define TIM_CC4IE (1 << 4)
/* 0: CC4 interrupt disabled.
   1: CC4 interrupt enabled. */

/* Bit 3 - Capture/Compare 3 interrupt enable */
#define TIM_CC3IE (1 << 3)
/* 0: CC3 interrupt disabled
   1: CC3 interrupt enabled */

/* Bit 2 - Capture/Compare 2 interrupt enable */
#define TIM_CC2IE (1 << 2)
/* 0: CC2 interrupt disabled
   1: CC2 interrupt enabled */

/* Bit 1 - Capture/Compare 1 interrupt enable */
#define TIM_CC1IE (1 << 1)
/* 0: CC1 interrupt disabled
   1: CC1 interrupt enabled */

/* Bit 0 - Update interrupt enable */
#define TIM_UIE (1 << 0)
/* 0: Update interrupt disabled
   1: Update interrupt enabled */


/*-------------------------------------------------------------------------
* TIMx status register */
#define STM32F_TIM_SR 0x10

/* Bit 15:13 Reserved, always read as 0. */

/* Bit 12 - Capture/Compare 4 overcapture flag */
#define TIM_CC4OF (1 << 12)
/* refer to CC1OF description */

/* Bit 11 - Capture/Compare 3 overcapture flag */
#define TIM_CC3OF (1 << 11)
/* refer to CC1OF description */

/* Bit 10 - Capture/compare 2 overcapture flag */
#define TIM_CC2OF (1 << 10)
/* refer to CC1OF description */

/* Bit 9 - Capture/Compare 1 overcapture flag */
#define TIM_CC1OF (1 << 9)
/* This flag is set by hardware only when the corresponding channel is 
   configured in input capture mode. It is cleared by software by 
   writing it to ‘0.
   0: No overcapture has been detected
   1: The counter value has been captured in TIMx_CCR1 register while 
   CC1IF flag was already set */

/* Bits 8:7 Reserved, always read as 0. */

/* Bit 6 - Trigger interrupt flag */
#define TIM_TIF (1 << 6)
/* This flag is set by hardware on trigger event (active edge detected on 
   TRGI input when the slave mode controller is enabled in all modes but 
   gated mode. It is set when the counter starts or stops when gated mode 
   is selected. It is cleared by software.
   0: No trigger event occurred
   1: Trigger interrupt pending */

/* Bit 5 Reserved, always read as 0 */

/* Bit 4 - Capture/Compare 4 interrupt flag */
#define TIM_CC4IF (1 << 4)
/* refer to CC1IF description */

/* Bit 3 - Capture/Compare 3 interrupt flag */
#define TIM_CC3IF (1 << 3)
/* refer to CC1IF description */

/* Bit 2 - Capture/Compare 2 interrupt flag */
#define TIM_CC2IF (1 << 2)
/* refer to CC1IF description */

/* Bit 1 - Capture/compare 1 interrupt flag */
#define TIM_CC1IF (1 << 1)
/* If channel CC1 is configured as output:
   This flag is set by hardware when the counter matches the compare 
   value, with some exception in center-aligned mode (refer to the CMS bits 
   in the TIMx_CR1 register description). It is cleared by software.
   0: No match
   1: The content of the counter TIMx_CNT matches the content of the 
   TIMx_CCR1 register.
   When the contents of TIMx_CCR1 are greater than the contents of 
   TIMx_ARR, the CC1IF bit goes high on the counter overflow (in 
   upcounting and up/down-counting modes) or underflow (in downcounting mode)
   If channel CC1 is configured as input:
   This bit is set by hardware on a capture. It is cleared by software or 
   by reading the TIMx_CCR1 register.
   0: No input capture occurred
   1: The counter value has been captured in TIMx_CCR1 register (An edge 
   has been detected on IC1 which matches the selected polarity) */

/* Bit 0 - Update interrupt flag */
#define TIM_UIF (1 << 0)
/* ● This bit is set by hardware on an update event. It is cleared by software.
   0: No update occurred.
   1: Update interrupt pending. This bit is set by hardware when the 
   registers are updated:
   ● At overflow or underflow (for TIM2 to TIM5) and if UDIS=0 
   in the TIMx_CR1 register.
   ● When CNT is reinitialized by software using the UG bit in TIMx_EGR 
   register, if URS=0 and UDIS=0 in the TIMx_CR1 register.
   When CNT is reinitialized by a trigger event (refer to the synchro 
   control register description), if URS=0 and UDIS=0 in the 
   TIMx_CR1 register. */


/*-------------------------------------------------------------------------
 * TIMx event generation register */
#define STM32F_TIM_EGR 0x14

/* [15..7] Reserved, always read as 0. */

/* Bit 6 - Trigger generation */
#define TIM_TG (1 << 6)
/* This bit is set by software in order to generate an event, it is 
   automatically cleared by hardware.
   0: No action
   1: The TIF flag is set in TIMx_SR register. Related interrupt or DMA 
   transfer can occur if enabled. */

/* Bit 5 Reserved, always read as 0. */

/* Bit 4 - Capture/compare 4 generation */
#define TIM_CC4G (1 << 4)
/* refer to CC1G description */

/* Bit 3 - Capture/compare 3 generation */
#define TIM_CC3G (1 << 3)
/* refer to CC1G description */

/* Bit 2 - Capture/compare 2 generation */
#define TIM_CC2G (1 << 2)
/* refer to CC1G description */

/* Bit 1 - Capture/compare 1 generation */
#define TIM_CC1G (1 << 1)
/* This bit is set by software in order to generate an event, it is 
   automatically cleared by hardware.
   0: No action
   1: A capture/compare event is generated on channel 1:
   If channel CC1 is configured as output:
   CC1IF flag is set, Corresponding interrupt or DMA request is sent 
   if enabled.
   If channel CC1 is configured as input:
   The current value of the counter is captured in TIMx_CCR1 register. 
   The CC1IF flag is set, the corresponding interrupt or DMA request 
   is sent if enabled. The CC1OF flag is set if the CC1IF flag 
   was already high. */

/* Bit 0 - Update generation */
#define TIM_UG (1 << 0)
/* This bit can be set by software, it is automatically cleared by hardware.
   0: No action
   1: Re-initialize the counter and generates an update of the registers. 
   Note that the prescaler counter is cleared too (anyway the prescaler 
   ratio is not affected). The counter is cleared if the center-aligned 
   mode is selected or if DIR=0 (upcounting), else it takes the 
   auto-reload value (TIMx_ARR) if DIR=1 (downcounting). */


/*-------------------------------------------------------------------------
 * TIMx capture/compare mode register 1 */
#define STM32F_TIM_CCMR1 0x18

/* The channels can be used in input (capture mode) or in output 
   (compare mode). The direction of a channel is defined by configuring the 
   corresponding CCxS bits. All the other bits of this register have a 
   different function in input and in output mode. For a given bit, OCxx 
   describes its function when the channel is configured in output, ICxx 
   describes its function when the channel is configured in input. So you 
   must take care that the same bit can have a different meaning for the 
   input stage and for the output stage. */


/* Bit 15 - Output compare 2 clear enable */
#define TIM_OC2CE (1 << 15)

/* Bits [14..12] - Output compare 2 mode */
#define TIM_OC2M_MSK (((1 << (2 + 1)) - 1) << 12)
#define TIM_OC2M_SET(VAL) (((VAL) << 12) & OC2M_MSK)
#define TIM_OC2M_GET(REG) (((REG) & OC2M_MSK) >> 12)

#define TIM_OC2M_ACTIVE_ON_MATCH (1 << 12)
#define TIM_OC2M_INACTIVE_ON_MATCH (2 << 12)
#define TIM_OC2M_TOGGLE (3 << 12)
#define TIM_OC2M_FORCE_INACTIVE (4 << 12)
#define TIM_OC2M_FORCE_ACTIVE (5 << 12)
#define TIM_OC2M_PWM_MODE1 (6 << 12)
#define TIM_OC2M_PWM_MODE2 (7 << 12)

/* Bit 11 - Output compare 2 preload enable */
#define TIM_OC2PE (1 << 11)

/* Bit 10 - Output compare 2 fast enable */
#define TIM_OC2FE (1 << 10)

/* Bits [9..8] - Capture/Compare 2 selection */
#define TIM_CC2S_MSK (((1 << (1 + 1)) - 1) << 8)
#define TIM_CC2S_SET(VAL) (((VAL) << 8) & CC2S_MSK)
#define TIM_CC2S_GET(REG) (((REG) & CC2S_MSK) >> 8)
#define TIM_CC2S_OUT (0x0 << 8)
#define TIM_CC2S_TI2 (0x1 << 8)
#define TIM_CC2S_TI1 (0x2 << 8)
#define TIM_CC2S_TRC (0x3 << 8)
/* This bit-field defines the direction of the channel (input/output) as 
   well as the used input.
   00: CC2 channel is configured as output
   01: CC2 channel is configured as input, IC2 is mapped on TI2
   10: CC2 channel is configured as input, IC2 is mapped on TI1
   11: CC2 channel is configured as input, IC2 is mapped on TRC. This mode 
   is working only if an internal trigger input is selected through the 
   TS bit (TIMx_SMCR register)
   Note: CC2S bits are writable only when the channel is OFF 
   (CC2E = 0 in TIMx_CCER). */

/* Bit 7 - Output compare 1 clear enable */
#define TIM_OC1CE (1 << 7)
/* OC1CE: Output Compare 1 Clear Enable
   0: OC1Ref is not affected by the ETRF input
   1: OC1Ref is cleared as soon as a High level is detected on ETRF input */

/* Bits [6..4] - Output compare 1 mode */
#define TIM_OC1M ((6 - 4) << 4)
#define TIM_OC1M_MSK (((1 << (2 + 1)) - 1) << 4)
#define TIM_OC1M_SET(VAL) (((VAL) << 12) & OC1M_MSK)
#define TIM_OC1M_GET(REG) (((REG) & OC1M_MSK) >> 4)

#define TIM_OC1M_ACTIVE_ON_MATCH (1 << 4)
#define TIM_OC1M_INACTIVE_ON_MATCH (2 << 4)
#define TIM_OC1M_TOGGLE (3 << 4)
#define TIM_OC1M_FORCE_INACTIVE (4 << 4)
#define TIM_OC1M_FORCE_ACTIVE (5 << 4)
#define TIM_OC1M_PWM_MODE1 (6 << 4)
#define TIM_OC1M_PWM_MODE2 (7 << 4)
/* These bits define the behavior of the output reference signal OC1REF from 
   which OC1 and OC1N are derived. OC1REF is active high whereas OC1 and 
   OC1N active level depends on CC1P and CC1NP bits.
   000: Frozen - The comparison between the output compare register 
   TIMx_CCR1 and the counter TIMx_CNT has no effect on the outputs.(this 
   mode is used to generate a timing base).
   001: Set channel 1 to active level on match. OC1REF signal is forced 
   high when the counter TIMx_CNT matches the capture/compare 
   register 1 (TIMx_CCR1).
   010: Set channel 1 to inactive level on match. OC1REF signal is forced 
   low when the counter TIMx_CNT matches the capture/compare register 
   1 (TIMx_CCR1).
   011: Toggle - OC1REF toggles when TIMx_CNT=TIMx_CCR1.
   100: Force inactive level - OC1REF is forced low.
   101: Force active level - OC1REF is forced high.
   110: PWM mode 1 - In upcounting, channel 1 is active as long as 
   TIMx_CNT<TIMx_CCR1 else inactive. In downcounting, channel 1 is 
   inactive (OC1REF=‘0) as long as TIMx_CNT>TIMx_CCR1 else active (OC1REF=1).
   111: PWM mode 2 - In upcounting, channel 1 is inactive as long as
   TIMx_CNT<TIMx_CCR1 else active. In downcounting, channel 1 is active 
   as long as TIMx_CNT>TIMx_CCR1 else inactive.
   Note: 1: These bits can not be modified as long as LOCK level 3 has 
   been programmed (LOCK bits in TIMx_BDTR register) and CC1S=00 (the 
   channel is configured in output).
   2: In PWM mode 1 or 2, the OCREF level changes only when the result of 
   the comparison changes or when the output compare mode switches from 
   “frozen” mode to “PWM” mode. */

/* Bit 3 - Output compare 1 preload enable */
#define TIM_OC1PE (1 << 3)
/* 0: Preload register on TIMx_CCR1 disabled. TIMx_CCR1 can be written at 
   anytime, the new value is taken in account immediately.
   1: Preload register on TIMx_CCR1 enabled. Read/Write operations access 
   the preload register. TIMx_CCR1 preload value is loaded in the active 
   register at each update event.
   Note: 1: These bits can not be modified as long as LOCK level 3 has been 
   programmed (LOCK bits in TIMx_BDTR register) and CC1S=00 (the channel is 
   configured in output).
   2: The PWM mode can be used without validating the preload register only 
   in one-pulse mode (OPM bit set in TIMx_CR1 register). Else the behavior 
   is not guaranteed. */

/* Bit 2 - Output compare 1 fast enable */
#define TIM_OC1FE (1 << 2)
/* This bit is used to accelerate the effect of an event on the trigger in 
   input on the CC output.
   0: CC1 behaves normally depending on counter and CCR1 values even when 
   the trigger is ON. The minimum delay to activate CC1 output when an 
   edge occurs on the trigger input is 5 clock cycles.
   1: An active edge on the trigger input acts like a compare match on 
   CC1 output. Then, OC is set to the compare level independently from the 
   result of the comparison. Delay to sample the trigger input and to 
   activate CC1 output is reduced to 3 clock cycles. OCFE acts only if 
   the channel is configured in PWM1 or PWM2 mode. */

/* Bits [1..0] - Capture/Compare 1 selection */
#define TIM_CC1S ((0x3) << 0)
#define TIM_CC1S_OUT (0x0 << 0)
#define TIM_CC1S_TI1 (0x1 << 0)
#define TIM_CC1S_TI2 (0x2 << 0)
#define TIM_CC1S_TRC (0x3 << 0)
/* This bit-field defines the direction of the channel (input/output) as 
   well as the used input.
   00: CC1 channel is configured as output.
   01: CC1 channel is configured as input, IC1 is mapped on TI1.
   10: CC1 channel is configured as input, IC1 is mapped on TI2.
   11: CC1 channel is configured as input, IC1 is mapped on TRC. This 
   mode is working only if an internal trigger input is selected through 
   TS bit (TIMx_SMCR register)
   Note: CC1S bits are writable only when the channel is OFF (CC1E = 0 
   in TIMx_CCER). */


/* Input capture mode */

/* Bits [15..12] - Input capture 2 filter */
#define TIM_IC2F ((15 - 12) << 12)

/* Bits [11..10] - Input capture 2 prescaler */
#define TIM_IC2PSC_MSK (((1 << (1 + 1)) - 1) << 10)
#define TIM_IC2PSC_SET(VAL) (((VAL) << 10) & TIM_IC2PSC_MSK)
#define TIM_IC2PSC_GET(REG) (((REG) & TIM_IC2PSC_MSK) >> 10)

/* Bits [9..8] - Capture/compare 2 selection */
#define TIM_CC2S ((9 - 8) << 8)
/* This bit-field defines the direction of the channel (input/output) as 
   well as the used input.
   00: CC2 channel is configured as output.
   01: CC2 channel is configured as input, IC2 is mapped on TI2.
   10: CC2 channel is configured as input, IC2 is mapped on TI1.
   11: CC2 channel is configured as input, IC2 is mapped on TRC. This mode 
   is working only if an internal trigger input is selected through TS 
   bit (TIMx_SMCR register)
   Note: CC2S bits are writable only when the channel is OFF 
   (CC2E = 0 in TIMx_CCER). */
#define TIM_CC2S_OUT (0x0 << 8)
#define TIM_CC2S_TI2 (0x1 << 8)
#define TIM_CC2S_TI1 (0x2 << 8)
#define TIM_CC2S_TRC (0x3 << 8)

/* Bits [7..4] - Input capture 1 filter */
#define TIM_IC1F ((7 - 4) << 4)
#define TIM_IC1F_MSK (((1 << (7 - 4 + 1)) - 1) << 4)
#define TIM_IC1F_SET(VAL) (((VAL) << 4) & TIM_IC1F_MSK)
#define TIM_IC1F_GET(REG) (((REG) & TIM_IC1F_MSK) >> 4)
/* This bit-field defines the frequency used to sample TI1 input and the 
   length of the digital filter applied to TI1. The digital filter is 
   made of an event counter in which N events are needed to validate 
   a transition on the output:
   1000: fSAMPLING=fDTS/8, N=6
   0000: No filter, sampling is done at fDTS
   1001: fSAMPLING=fDTS/8, N=8
   0001: fSAMPLING=fCK_INT, N=2
   0010: fSAMPLING=fCK_INT, N=4
   1010: fSAMPLING=fDTS/16, N=5
   1011: fSAMPLING=fDTS/16, N=6
   0011: fSAMPLING=fCK_INT, N=8
   1100: fSAMPLING=fDTS/16, N=8
   0100: fSAMPLING=fDTS/2, N=6
   0101: fSAMPLING=fDTS/2, N=8
   1101: fSAMPLING=fDTS/32, N=5
   1110: fSAMPLING=fDTS/32, N=6
   0110: fSAMPLING=fDTS/4, N=6
   1111: fSAMPLING=fDTS/32, N=8
   0111: fSAMPLING=fDTS/4, N=8
   Note: In current silicon revision, fDTS is replaced in the 
   formula by CK_INT when ICxF[3:0]= 1, 2 or 3. */
#define TIM_IC1F_2 (0x1 << 4)
#define TIM_IC1F_4 (0x2 << 4)
#define TIM_IC1F_5 (0xa << 4)
#define TIM_IC1F_6 (0xb << 4)
#define TIM_IC1F_8 (0x3 << 4)

/* Bits [3..2] - Input capture 1 prescaler */
#define TIM_IC1PSC ((3 - 2) << 2)
/* This bit-field defines the ratio of the prescaler acting on CC1 input (IC1).
   The prescaler is reset as soon as CC1E=0 (TIMx_CCER register).
   00: no prescaler, capture is done each time an edge is detected 
   on the capture input
   01: capture is done once every 2 events
   10: capture is done once every 4 events
   11: capture is done once every 8 events */

/* Bits [1..0] - Capture/Compare 1 selection */
#define TIM_CC1S ((0x3) << 0)
/* This bit-field defines the direction of the channel (input/output) as 
   well as the used input.
   00: CC1 channel is configured as output
   01: CC1 channel is configured as input, IC1 is mapped on TI1
   10: CC1 channel is configured as input, IC1 is mapped on TI2
   11: CC1 channel is configured as input, IC1 is mapped on TRC. This 
   mode is working only if an internal trigger input is selected through TS 
   bit (TIMx_SMCR register)
   Note: CC1S bits are writable only when the channel is OFF 
   (CC1E = 0 in TIMx_CCER). */


/*-------------------------------------------------------------------------
 * TIMx capture/compare mode register 2 */
#define STM32F_TIM_CCMR2 0x1C
/* Refer to the above CCMR1 register description. */

/* Output compare mode */

/* Bit 15 - Output compare 4 clear enable */
#define TIM_OC4CE (1 << 15)

/* Bits [14..12] - Output compare 4 mode */
#define TIM_OC4M ((14 - 12) << 12)

#define TIM_OC4M_ACTIVE_ON_MATCH (1 << 12)
#define TIM_OC4M_INACTIVE_ON_MATCH (2 << 12)
#define TIM_OC4M_TOGGLE (3 << 12)
#define TIM_OC4M_FORCE_INACTIVE (4 << 12)
#define TIM_OC4M_FORCE_ACTIVE (5 << 12)
#define TIM_OC4M_PWM_MODE1 (6 << 12)
#define TIM_OC4M_PWM_MODE2 (7 << 12)

/* Bit 11 - Output compare 4 preload enable */
#define TIM_OC4PE (1 << 11)

/* Bit 10 - Output compare 4 fast enable */
#define TIM_OC4FE (1 << 10)

/* Bits [9..8] - Capture/Compare 4 selection */
#define TIM_CC4S ((9 - 8) << 8)
/* This bit-field defines the direction of the channel (input/output) as 
   well as the used input.
   00: CC4 channel is configured as output
   01: CC4 channel is configured as input, IC4 is mapped on TI4
   10: CC4 channel is configured as input, IC4 is mapped on TI3
   11: CC4 channel is configured as input, IC4 is mapped on TRC. This 
   mode is working only if an internal trigger input is selected through 
   TS bit (TIMx_SMCR register)
   Note: CC4S bits are writable only when the channel is OFF 
   (CC4E = 0 in TIMx_CCER). */

#define TIM_CC4S_OUT (0x0 << 8)
#define TIM_CC4S_TI3 (0x1 << 8)
#define TIM_CC4S_TI4 (0x2 << 8)
#define TIM_CC4S_TRC (0x3 << 8)

/* Bit 7 - Output compare 3 clear enable */
#define TIM_OC3CE (1 << 7)

/* Bits [6..4] - Output compare 3 mode */
#define TIM_OC3M ((6 - 4) << 4)

#define TIM_OC3M_ACTIVE_ON_MATCH (1 << 4)
#define TIM_OC3M_INACTIVE_ON_MATCH (2 << 4)
#define TIM_OC3M_TOGGLE (3 << 4)
#define TIM_OC3M_FORCE_INACTIVE (4 << 4)
#define TIM_OC3M_FORCE_ACTIVE (5 << 4)
#define TIM_OC3M_PWM_MODE1 (6 << 4)
#define TIM_OC3M_PWM_MODE2 (7 << 4)

/* Bit 3 - Output compare 3 preload enable */
#define TIM_OC3PE (1 << 3)

/* Bit 2 - Output compare 3 fast enable */
#define TIM_OC3FE (1 << 2)

/* Bits [1..0] - Capture/Compare 3 selection */
#define TIM_CC3S ((1 - 0) << 0)
#define TIM_CC3S_OUT (0x0 << 0)
#define TIM_CC3S_TI3 (0x1 << 0)
#define TIM_CC3S_TI4 (0x2 << 0)
#define TIM_CC3S_TRC (0x3 << 0)
/* This bit-field defines the direction of the channel (input/output) as 
   well as the used input.
   00: CC3 channel is configured as output
   01: CC3 channel is configured as input, IC3 is mapped on TI3
   10: CC3 channel is configured as input, IC3 is mapped on TI4
   11: CC3 channel is configured as input, IC3 is mapped on TRC. This mode 
   is working only if an internal trigger input is selected through TS 
   bit (TIMx_SMCR register)
   Note: CC3S bits are writable only when the channel is OFF (CC3E = 0 
   in TIMx_CCER). */


/* Input capture mode */

/* Bits [15..12] - Input capture 4 filter */
#define TIM_IC4F ((15 - 12) << 12)

/* Bits [11..10] - Input capture 4 prescaler */
#define TIM_IC4PSC ((11 - 10) << 10)

/* Bits [9..8] - Capture/Compare 4 selection */
#define TIM_CC4S ((9 - 8) << 8)
/* This bit-field defines the direction of the channel (input/output) as 
   well as the used input.
   00: CC4 channel is configured as output
   01: CC4 channel is configured as input, IC4 is mapped on TI4
   10: CC4 channel is configured as input, IC4 is mapped on TI3
   11: CC4 channel is configured as input, IC4 is mapped on TRC. This mode 
   is working only if an internal trigger input is selected through TS 
   bit (TIMx_SMCR register)
   Note: CC4S bits are writable only when the channel is OFF (CC4E = 0 
   in TIMx_CCER). */

/* Bits [7..4] - Input capture 3 filter */
#define TIM_IC3F ((7 - 4) << 4)

/* Bits [3..2] - Input capture 3 prescaler */
#define TIM_IC3PSC ((3 - 2) << 2)

/* Bits [1..0] - Capture/Compare 3 selection */
#define TIM_CC3S ((1 - 0) << 0)
/* This bit-field defines the direction of the channel (input/output) as 
   well as the used input.
   00: CC3 channel is configured as output
   01: CC3 channel is configured as input, IC3 is mapped on TI3
   10: CC3 channel is configured as input, IC3 is mapped on TI4
   11: CC3 channel is configured as input, IC3 is mapped on TRC. This mode 
   is working only if an internal trigger input is selected through TS 
   bit (TIMx_SMCR register)
   Note: CC3S bits are writable only when the channel is OFF (CC3E = 0 
   in TIMx_CCER). */


/*-------------------------------------------------------------------------
 * TIMx capture/compare enable register */
#define STM32F_TIM_CCER 0x20

/* Bit 15 - Capture/Compare 4 output Polarity. */
#define TIM_CC4NP (1 << 15)
/* Refer to CC1NP description */

/* Bit 14 Reserved, always read as 0. */


/* Bit 13 - Capture/Compare 4 output Polarity. */
#define TIM_CC4P (1 << 13)
/* refer to CC1P description */

/* Bit 12 - Capture/Compare 4 output enable. */
#define TIM_CC4E (1 << 12)
/* refer to CC1E description */

/* Bit 13 - Capture/Compare 3 output Polarity. */
#define TIM_CC3NP (1 << 13)
/* refer to CC1NP description */

/* Bit 12 Reserved, always read as 0. */


/* [11..10] Reserved, always read as 0. */


/* Bit 9 - Capture/Compare 3 output Polarity. */
#define TIM_CC3P (1 << 9)
/* refer to CC1P description */

/* Bit 8 - Capture/Compare 3 output enable. */
#define TIM_CC3E (1 << 8)
/* refer to CC1E description */

/* Bit 7 - Capture/Compare 2 output Polarity. */
#define TIM_CC2NP (1 << 7)
/* refer to CC1NP description */

/* Bit 6 Reserved, always read as 0. */


/* Bit 5 - Capture/Compare 2 output Polarity. */
#define TIM_CC2P (1 << 5)
/* refer to CC1P description */

/* Bit 4 - Capture/Compare 2 output enable. */
#define TIM_CC2E (1 << 4)
/* refer to CC1E description */

/* Bit 3 - Capture/Compare 1 output Polarity. */
#define TIM_CC1NP (1 << 3)
/* CC1 channel configured as output:
   CC1NP must be kept cleared in this case.
   CC1 channel configured as input:
   This bit is used in conjunction with CC1P to define TI1FP1/TI2FP1 
   polarity. refer to CC1P description. */

/* Bit 2 - Capture/Compare 1 complementary output enable . */
#define TIM_CC1NE (2 << 1)

/* Bit 1 - Capture/Compare 1 output Polarity. */
#define TIM_CC1P (1 << 1)
/* CC1 channel configured as output:
   0: OC1 active high
   1: OC1 active low
   CC1 channel configured as input:
   CC1NP/CC1P bits select TI1FP1 and TI2FP1 polarity for trigger or 
   capture operations.
   00: noninverted/rising edge Circuit is sensitive to TIxFP1 rising edge 
   (capture, trigger in reset, external clock or trigger mode), TIxFP1 
   is not inverted (trigger in gated mode, encoder mode).
   01: inverted/falling edge 
   Circuit is sensitive to TIxFP1 falling edge (capture, trigger in 
   reset, external clock or trigger mode), TIxFP1 is inverted 
   (trigger in gated mode, encoder mode).
   10: reserved, do not use this configuration.
   11: noninverted/both edges 
   Circuit is sensitive to both TIxFP1 rising and falling edges (capture, 
   trigger in reset, external clock or trigger mode), TIxFP1 is not 
   inverted (trigger in gated mode). This configuration must not be 
   used for encoder mode. */

/* Bit 0 - Capture/Compare 1 output enable. */
#define TIM_CC1E (1 << 0)
/* CC1 channel configured as output:
   0: Off - OC1 is not active
   1: On - OC1 signal is output on the corresponding output pin CC1 channel 
   configured as input:
   This bit determines if a capture of the counter value can actually be 
   done into the input capture/compare register 1 (TIMx_CCR1) or not.
   0: Capture disabled
   1: Capture enabled */


/*-------------------------------------------------------------------------
 * TIMx counter (TIMx_CNT) */
#define STM32F_TIM_CNT 0x24


/*-------------------------------------------------------------------------
 * TIMx prescaler (TIMx_PSC) */
#define STM32F_TIM_PSC 0x28


/*-------------------------------------------------------------------------
 * TIMx auto-reload register */
#define STM32F_TIM_ARR 0x2C


/*-------------------------------------------------------------------------
 * TIM1&TIM8 repetition counter register */
#define STM32F_TIM_RCR 0x30

/* [15..8] Reserved, must be kept at reset value. */

/* Bits [7..0] - Repetition counter value */
#define TIM_REP_MSK (((1 << (7 + 1)) - 1) << 0)
#define TIM_REP_SET(VAL) (((VAL) << 0) & REP_MSK)
#define TIM_REP_GET(REG) (((REG) & REP_MSK) >> 0)
/* These bits allow the user to set-up the update rate of the compare 
   registers (i.e. periodic transfers from preload to active registers) 
   when preload registers are enable, as well as the update interrupt 
   generation rate, if this interrupt is enable.
   Each time the REP_CNT related downcounter reaches zero, an update event 
   is generated and it restarts counting from REP value. As REP_CNT is 
   reloaded with REP value only at the repetition update event U_RC, any 
   write to the TIMx_RCR register is not taken in account until the next 
   repetition update event.
   It means in PWM mode (REP+1) corresponds to:
   – the number of PWM periods in edge-aligned mode
   – the number of half PWM period in center-aligned mode. */


/*-------------------------------------------------------------------------
 * TIMx capture/compare register 1 */
#define STM32F_TIM_CCR1 0x34


/*-------------------------------------------------------------------------
 * TIMx capture/compare register 2 */
#define STM32F_TIM_CCR2 0x38


/*-------------------------------------------------------------------------
 * TIMx capture/compare register 3 (TIMx_CCR3) (only available on 
 * TIM2 and TIM5) */
#define STM32F_TIM_CCR3 0x3c


/*-------------------------------------------------------------------------
 * TIMx capture/compare register 4 (TIMx_CCR4) (only available on 
 * TIM2 and TIM5) */
#define STM32F_TIM_CCR4 0x40


/*-------------------------------------------------------------------------
 * TIM1&TIM8 break and dead-time register */
#define STM32F_TIM_BDTR 0x44


/* Bit 15 - Main output enable */
#define TIM_MOE (1 << 15)
/* This bit is cleared asynchronously by hardware as soon as the break 
   input is active. It is set by software or automatically depending on the 
   AOE bit. It is acting only on the channels which are configured in output.
   0: OC and OCN outputs are disabled or forced to idle state.
   1: OC and OCN outputs are enabled if their respective enable bits are 
   set (CCxE, CCxNE in TIMx_CCER register).
   See OC/OCN enable description for more details (Section 13.4.9: TIM1&TIM8
   capture/compare enable register (TIMx_CCER) on page 344). */

/* Bit 14 - Automatic output enable */
#define TIM_AOE (1 << 14)
/* 0: MOE can be set only by software
   1: MOE can be set by software or automatically at the next update event 
   (if the break input is not be active)
   Note: This bit can not be modified as long as LOCK level 1 has been 
   programmed (LOCK bits in TIMx_BDTR register). */

/* Bit 13 - Break polarity */
#define TIM_BKP (1 << 13)
/* 0: Break input BRK is active low
   1: Break input BRK is active high
   Note: This bit can not be modified as long as LOCK level 1 has been 
   programmed (LOCK bits in TIMx_BDTR register).
   Note: Any write operation to this bit takes a delay of 1 APB clock 
   cycle to become effective. */

/* Bit 12 - Break enable */
#define TIM_BKE (1 << 12)
/* 0: Break inputs (BRK and CCS clock failure event) disabled 
   1: Break inputs (BRK and CCS clock failure event) enabled
   Note: This bit cannot be modified when LOCK level 1 has been 
   programmed (LOCK bits in TIMx_BDTR register).
   Note: Any write operation to this bit takes a delay of 1 APB clock 
   cycle to become effective. */

/* Bit 11 - Off-state selection for Run mode */
#define TIM_OSSR (1 << 11)
/* This bit is used when MOE=1 on channels having a complementary output 
   which are configured as outputs. OSSR is not implemented if no 
   complementary output is implemented in the timer.
   See OC/OCN enable description for more details (Section 13.4.9: 
   TIM1&TIM8 capture/compare enable register (TIMx_CCER) on page 344).
   0: When inactive, OC/OCN outputs are disabled (OC/OCN enable output 
   signal=0).
   1: When inactive, OC/OCN outputs are enabled with their inactive level 
   as soon as CCxE=1 or CCxNE=1. Then, OC/OCN enable output signal=1
   Note: This bit can not be modified as soon as the LOCK level 2 has 
   been programmed (LOCK bits in TIMx_BDTR register). */

/* Bit 10 - Off-state selection for Idle mode */
#define TIM_OSSI (1 << 10)
/* This bit is used when MOE=0 on channels configured as outputs.
   See OC/OCN enable description for more details (Section 13.4.9: TIM1&TIM8
   capture/compare enable register (TIMx_CCER) on page 344).
   0: When inactive, OC/OCN outputs are disabled (OC/OCN enable 
   output signal=0).
   1: When inactive, OC/OCN outputs are forced first with their idle level 
   as soon as CCxE=1 or CCxNE=1. OC/OCN enable output signal=1)
   Note: This bit can not be modified as soon as the LOCK level 2 has been 
   programmed (LOCK bits in TIMx_BDTR register). */

/* Bits [9..8] - Lock configuration */
#define TIM_LOCK_MSK (((1 << (1 + 1)) - 1) << 8)
#define TIM_LOCK_SET(VAL) (((VAL) << 8) & LOCK_MSK)
#define TIM_LOCK_GET(REG) (((REG) & LOCK_MSK) >> 8)
/* These bits offer a write protection against software errors.
   00: LOCK OFF - No bit is write protected.
   01: LOCK Level 1 = DTG bits in TIMx_BDTR register, OISx and OISxN bits 
   in TIMx_CR2 register and BKE/BKP/AOE bits in TIMx_BDTR register can no 
   longer be written.
   10: LOCK Level 2 = LOCK Level 1 + CC Polarity bits (CCxP/CCxNP bits 
   in TIMx_CCER register, as long as the related channel is configured in 
   output through the CCxS bits) as well as OSSR and OSSI bits can 
   no longer be written.
   11: LOCK Level 3 = LOCK Level 2 + CC Control bits (OCxM and OCxPE bits in
   TIMx_CCMRx registers, as long as the related channel is configured in 
   output through the CCxS bits) can no longer be written.
   Note: The LOCK bits can be written only once after the reset. Once the 
   TIMx_BDTR register has been written, their content is frozen 
   until the next reset. */

/* Bits [7..0] - Dead-time generator setup */
#define TIM_DTG_MSK (((1 << (7 + 1)) - 1) << 0)
#define TIM_DTG_SET(VAL) (((VAL) << 0) & DTG_MSK)
#define TIM_DTG_GET(REG) (((REG) & DTG_MSK) >> 0)
/* This bit-field defines the duration of the dead-time inserted between 
   the complementary outputs. DT correspond to this duration.
   DTG[7:5]=0xx => DT=DTG[7:0]x tdtg with tdtg=tDTS.
   DTG[7:5]=10x => DT=(64+DTG[5:0])xtdtg with Tdtg=2xtDTS.
   DTG[7:5]=110 => DT=(32+DTG[4:0])xtdtg with Tdtg=8xtDTS.
   DTG[7:5]=111 => DT=(32+DTG[4:0])xtdtg with Tdtg=16xtDTS.
   Example if TDTS=125ns (8MHz), dead-time possible values are:
   0 to 15875 ns by 125 ns steps,
   16 us to 31750 ns by 250 ns steps,
   32 us to 63us by 1 us steps,
   64 us to 126 us by 2 us steps
   Note: This bit-field can not be modified as long as LOCK level 1, 2 or 
   3 has been programmed (LOCK bits in TIMx_BDTR register). */


/*-------------------------------------------------------------------------
 * TIMx DMA control register */
#define STM32F_TIM_DCR 0x48

/* [15..13] Reserved, always read as 0 */

/* Bits [12..8] - DMA burst length */
#define TIM_DBL_MSK (((1 << (4 + 1)) - 1) << 8)
#define TIM_DBL_SET(VAL) (((VAL) << 8) & DBL_MSK)
#define TIM_DBL_GET(REG) (((REG) & DBL_MSK) >> 8)
/* This 5-bit vector defines the number of DMA transfers (the timer 
   recognizes a burst transfer when a read or a write access is done to 
   the TIMx_DMAR address).
   00000: 1 transfer,
   00001: 2 transfers,
   00010: 3 transfers,
   ...
   10001: 18 transfers. */

/* [7..5] Reserved, always read as 0 */

/* Bits [4..0] - DMA base address */
#define TIM_DBA_MSK (((1 << (4 + 1)) - 1) << 0)
#define TIM_DBA_SET(VAL) (((VAL) << 0) & DBA_MSK)
#define TIM_DBA_GET(REG) (((REG) & DBA_MSK) >> 0)
/* This 5-bit vector defines the base-address for DMA transfers (when 
   read/write access are done through the TIMx_DMAR address). DBA is defined 
   as an offset starting from the address of the TIMx_CR1 register.
   Example:
   00000: TIMx_CR1,
   00001: TIMx_CR2,
   00010: TIMx_SMCR,
   ...
   Example: Let us consider the following transfer: DBL = 7 transfers & 
   DBA = TIMx_CR1. In this case the transfer is done to/from 7 registers 
   starting from the TIMx_CR1 address.. */


/*-------------------------------------------------------------------------
 * TIMx DMA address for full transfer (TIMx_DMAR)
Address offset: 0x4C */


/*-------------------------------------------------------------------------
 * TIM2 option register */
#define TIM_TIM2_OR 0x50

/* [15..12] Reserved */

/* Bits [11..10] - Internal trigger 1 remap */
#define TIM_ITR1_RMP ((11 - 10) << 10)
/* Set and cleared by software.
   00: TIM8_TRGOUT
   01: PTP trigger output is connected to TIM2_ITR1
   10: OTG FS SOF is connected to the TIM2_ITR1 input
   11: OTG HS SOF is connected to the TIM2_ITR1 input */

/* [9..0] Reserved */


/*-------------------------------------------------------------------------
 * TIM5 option register */
#define TIM_TIM5_OR 0x50

/* [15..8] Reserved */

/* Bits [7..6] - Timer Input 4 remap */
#define TIM_TI4_RMP ((7 - 6) << 6)
/* Set and cleared by software.
   00: TIM5 Channel4 is connected to the GPIO: Refer to the Alternate 
   function mapping table in the STM32F20x and STM32F21x datasheets.
   01: the LSI internal clock is connected to the TIM5_CH4 input for 
   calibration purposes
   10: the LSE internal clock is connected to the TIM5_CH4 input for 
   calibration purposes
   11: the RTC output event is connected to the TIM5_CH4 input for 
   calibration purposes */

/* [5..0] Reserved */

#ifndef __ASSEMBLER__

#include <stdint.h>

struct stm32f_tim {
	volatile uint32_t cr1;
	volatile uint32_t cr2;
	volatile uint32_t smcr;
	volatile uint32_t dier;

	volatile uint32_t sr;
	volatile uint32_t egr;
	volatile uint32_t ccmr1;
	volatile uint32_t ccmr2;

	volatile uint32_t ccer;
	volatile uint32_t cnt;
	volatile uint32_t psc;
	volatile uint32_t arr;
	
	volatile uint32_t rcr;
	volatile uint32_t ccr1;
	volatile uint32_t ccr2;
	volatile uint32_t ccr3;

	volatile uint32_t ccr4;
	volatile uint32_t bdtr;
	volatile uint32_t dcr;
	volatile uint32_t dmar;

	volatile uint32_t or;
};

#endif /* __ASSEMBLER__ */


#endif /* __STM32F_TIMER_H__ */
